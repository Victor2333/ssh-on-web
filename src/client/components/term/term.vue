<template>
  <div style="text-align: left; height: 100%;" ref="termDiv"></div>
</template>
<script>
import { w3cwebsocket as W3cwebsocket } from "websocket";
import { hterm, lib } from "hterm-umdjs";
import GlobalStore from "../../global-store";
import _ from "lodash";
export default {
  model: {
    prop: "termConnected",
    event: "changeTermConnected"
  },
  props: ["termOptions", "termConnected", "navMini", "isActive"],
  connection: "",
  data() {
    return {
      auth: GlobalStore.auth,
      ws: null,
      io: null,
      cols: 80,
      rows: 30,
      terminal: null,
      debounceResize: null,
      wsConnected: false,
      firstRun: true
    };
  },
  watch: {
    termConnected: function(newVal) {
      if (newVal) this.socketOpen();
      else this.wsClose();
    },
    isActive: function(newVal) {
      if (newVal && this.firstRun) {
        this.initHterm(this, hterm, lib);
        this.firstRun = false;
      }
    }
  },
  mounted() {
    this.debounceResize = _.debounce(this.resizePty, 1000);
    if (this.isActive && this.firstRun) {
      this.initHterm(this, hterm, lib);
      this.firstRun = false;
    }

    // const that = this
    // import(/* webpackChunkName: "hterm" */ 'hterm-umdjs').then( module => {
    //  const hterm = module.hterm
    //  const lib = module.lib
    //  initHterm(that, hterm, lib)
    // })
  },
  beforeDestroy() {
    if (this.termConnected && this.ws) this.wsClose();
  },
  destroyed() {
    if (this.ws) this.ws.close();
  },
  methods: {
    sendMessage(op, data) {
      if (this.wsConnected && this.ws) {
        if (!this.navMini && op !== "resize") {
          this.$emit("update:navMini", true);
        }
        this.ws.send(JSON.stringify({ op, data }));
      } else if (op !== "resize") {
        console.warn("connection is not open.");
      }
    },
    initHterm(that, hterm1, lib1) {
      hterm1.defaultStorage = new lib1.Storage.Local();
      lib1.init(function() {
        // opt_profileName is the name of the terminal profile to load, or "default" if
        // not specified.  If you're using one of the persistent storage
        // implementations then this will scope all preferences read/writes to this
        // name.
        const optProfileName = "default";
        const t = new hterm1.Terminal(optProfileName);
        t.prefs_.set("alt-sends-what", "8-bit");
        // to support non-ascii,  ex: Chinese
        t.prefs_.set("send-encoding", "raw");
        t.prefs_.set(
          "font-family",
          "Droid Sans Mono for Powerline, courier new, Helvetica, Arial, sans-serif"
        );
        t.prefs_.set("font-size", "12px");

        t.onTerminalReady = () => {
          // Create a new terminal IO object and give it the foreground.
          // (The default IO object just prints warning messages about unhandled
          // things to the the JS console.)
          const io = t.io.push();
          that.io = io;

          io.onVTKeystroke = str => {
            // Do something useful with str here.
            // For example, Secure Shell forwards the string onto the NaCl plugin.
            // io.print(str)
            that.sendMessage("data", str);
          };

          io.sendString = str => {
            // Just like a keystroke, except str was generated by the terminal itself.
            // For example, when the user pastes a string.
            // Most likely you'll do the same thing as onVTKeystroke.
            that.sendMessage("data", str);
          };

          io.onTerminalResize = (columns, rows) => {
            // React to size changes here.
            // Secure Shell pokes at NaCl, which eventually results in
            // some ioctls on the host.
            // console.log(`resize, ${columns}, ${rows}`)
            that.cols = columns;
            that.rows = rows;
            // that.sendMessage("resize", { col: columns, row: rows });
            that.debounceResize();
          };

          // You can call io.push() to foreground a fresh io context, which can
          // be uses to give control of the terminal to something else.  When that
          // thing is complete, should call io.pop() to restore control to the
          // previous io object.
        };

        // console.log(that.$refs.termDiv)
        t.decorate(that.$refs.termDiv);
        t.setCursorPosition(0, 0);
        t.setCursorVisible(true);
        t.installKeyboard();
        that.terminal = t;
      }); // -- lib.init
    },

    resizePty() {
      this.sendMessage("resize", { col: this.cols, row: this.rows });
    },

    reqSShConnect(options) {
      const { sshuser, sshhost, sshport } = options;
      let port = 22;
      if (sshport !== null) port = sshport;
      this.sendMessage("connect", {
        sshuser: sshuser,
        sshhost: sshhost,
        sshport: port,
        cols: this.cols,
        rows: this.rows,
        options
      });
    },

    socketOpen() {
      const options = this.termOptions;
      this.connection = `${options.sshuser}@${options.sshhost}`;
      this.$emit("changeConnection", this.connection);

      let { host, protocol } = window.location;
      let wsUrl = `${protocol}//${host}/ws`.replace("http", "ws");

      this.ws = new W3cwebsocket(wsUrl, this.auth.token);
      this.ws.onopen = () => {
        this.wsConnected = true;
        if (this.terminal) this.terminal.focus();
        this.reqSShConnect(options);
      };
      this.ws.onclose = () => {
        this.wsConnected = false;
        this.$emit("changeTermConnected", this.wsConnected);
        this.io.println("Remotion connection closed.");
      };
      this.ws.onerror = () => {
        this.ws.close();
      };

      this.ws.onmessage = msg => {
        this.io.print(msg.data);
      };
    },

    wsClose() {
      this.io.print("\r\n");
      if (this.ws) this.ws.send(JSON.stringify({ op: "close" }));
    }
  }
};
</script>

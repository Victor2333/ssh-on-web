<template>
<div style='height: 100%'>
  <!--
  <button v-on:click='sendMessage' :disabled='!wsConnected'> send message </button><button v-on:click='connectToggle'> {{ wsConnected ? 'Disconnect' : 'Connect' }}</button>
  <div v-for='(msg, idx) in messages' :key='"msg" + idx'> {{ msg }} </div>
  -->
  <div style='display: flex; flex-direction:row; padding-bottom: 10px'>
    <button @click='inputConnection'>SSH to ...</button>
    <div style='padding: 5px;'> {{connection}} - {{wsConnected? "connected" : "disconnected" }} </div>
    <div style='padding: 5px; position: absolute; right: 10px; font-size: .8em;'> Make SSH easier </div>
  </div>
  <div style='text-align: left; position: relative; min-height: calc(100vh - 50px);' ref='termDiv'> </div>
</div>
</template>
<script lang='babel'>
import { w3cwebsocket as W3cwebsocket } from 'websocket'
import { hterm, lib } from 'hterm-umdjs'

export default {
  mounted () {
    const that = this
    hterm.defaultStorage = new lib.Storage.Local()
    lib.init(function () {
      // opt_profileName is the name of the terminal profile to load, or "default" if
      // not specified.  If you're using one of the persistent storage
      // implementations then this will scope all preferences read/writes to this
      // name.
      const optProfileName = 'default'
      const t = new hterm.Terminal(optProfileName)
      t.prefs_.set('alt-sends-what', '8-bit')
      // to support non-ascii,  ex: Chinese
      t.prefs_.set('send-encoding', 'raw')
      t.prefs_.set('font-family', 'Droid Sans Mono for Powerline, Helvetica, Arial, sans-serif')

      t.onTerminalReady = () => {
        // Create a new terminal IO object and give it the foreground.
        // (The default IO object just prints warning messages about unhandled
        // things to the the JS console.)
        const io = t.io.push()
        that.io = io

        io.onVTKeystroke = (str) => {
          // Do something useful with str here.
          // For example, Secure Shell forwards the string onto the NaCl plugin.
          // io.print(str)
          that.sendMessage('data', str)
        }

        io.sendString = (str) => {
          // Just like a keystroke, except str was generated by the terminal itself.
          // For example, when the user pastes a string.
          // Most likely you'll do the same thing as onVTKeystroke.
          that.sendMessage('data', str)
        }

        io.onTerminalResize = (columns, rows) => {
          // React to size changes here.
          // Secure Shell pokes at NaCl, which eventually results in
          // some ioctls on the host.
          // console.log(`resize, ${columns}, ${rows}`)
          that.cols = columns
          that.rows = rows
          that.sendMessage('resize', { col: columns, row: rows })
          /*
          if (that.wsConnected) {
            that.ws.send(JSON.stringify({ op: 'resize', data: { col: columns, row: rows } }))
          }
          */
        }

        // You can call io.push() to foreground a fresh io context, which can
        // be uses to give control of the terminal to something else.  When that
        // thing is complete, should call io.pop() to restore control to the
        // previous io object.
      }

      // console.log(that.$refs.termDiv)
      t.decorate(that.$refs.termDiv)
      t.setCursorPosition(0, 0)
      t.setCursorVisible(true)
      t.installKeyboard()

      /*
      t.io.print('Print a string without a newline')
      t.io.println('Print a string and add CRLF')
      t.io.println('Print a string and add CRLF')
      */
      // that.socketOpen()
    }) // -- lib.init
  },

  data () {
    return {
      messages: ['msg1', 'msg2'],
      ws: null,
      wsConnected: false,
      io: null,
      connection: 'None',
      cols: 80,
      rows: 30
    }
  },

  methods: {
    addMessage (msg) {
      this.messages.push(msg)
      this.messages = this.messages.slice(-10)
    },

    sendMessage (op, data) {
      if (this.wsConnected) {
        this.ws.send(JSON.stringify({ op, data }))
      } else {
        console.warn('connection is not open.')
      }
    },

    reqSShConnect (options) {
      const { sshuser, sshhost } = options
      this.sendMessage('connect', {
        sshuser: sshuser,
        sshhost: sshhost,
        sshport: 22,
        sshauth: 'password,keyboard-interactive',
        cols: this.cols,
        rows: this.rows
      })
    },

    inputConnection () {
      const input = prompt('Enter the connection string: user@hostname', 'user@hostname')
      if (input != null) {
        let matchResult = input.match(/^([^\s@]+)@([^\s@]+)$/)
        if (matchResult != null) {
          this.connection = input
          if (this.wsConnected) { this.ws.close() }
          this.socketOpen({ sshhost: matchResult[2], sshuser: matchResult[1] })
        } else {
          alert('invalid input')
        }
      }
    },

    socketOpen (options) {
      let { host, protocol } = window.location
      let wsUrl = `${protocol}//${host}/ws`.replace('http', 'ws')

      this.ws = new W3cwebsocket(wsUrl)
      this.ws.onopen = () => {
        this.wsConnected = true
        this.reqSShConnect(options)
      }
      this.ws.onclose = () => {
        this.wsConnected = false
        this.io.writeUTF16('Remotion connection closed.')
      }
      this.ws.onerror = () => { this.ws.close() }

      this.ws.onmessage = (msg) => {
        this.io.writeUTF16(msg.data)
      }
    },

    connectToggle () {
      if (this.wsConnected) this.ws.close()
      else this.socketOpen()
    }
  }
}
</script>

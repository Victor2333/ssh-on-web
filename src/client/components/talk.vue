<template>
  <v-app style="height: 100%">
    <v-toolbar dense dark>
      <v-btn icon>
        <v-icon>list</v-icon>
      </v-btn>
      <SSHTo :connectTo="socketOpen"/>
      <Keys/>
      <v-spacer></v-spacer>
      <span style="padding-right: 10px">{{connection}}</span>
      <v-icon small color="green" v-if="wsConnected">wifi_tethering</v-icon>
      <v-icon small color="red" v-if="!wsConnected">portable_wifi_off</v-icon>
      <v-btn
        small
        round
        v-on:click="connectToggle"
        v-if="connection != ''"
      >{{wsConnected? "Disconnect" : "Reconnect" }}</v-btn>
      <v-tooltip bottom>
        <v-btn v-on:click="logout" icon slot="activator">
          <v-icon>exit_to_app</v-icon>
        </v-btn>
        <span>Sign Out</span>
      </v-tooltip>
    </v-toolbar>
    <div style="text-align: left; position: relative; height: 100%;" ref="termDiv"></div>
  </v-app>
</template>
<script>
import { w3cwebsocket as W3cwebsocket } from "websocket";
import { hterm, lib } from "hterm-umdjs";
import GlobalStore from "../global-store";
import SSHTo from "./ssh-to/ssh-to.vue";
import Keys from "./keys/keys.vue";
import ls from "local-storage";

export default {
  components: {
    SSHTo,
    Keys
  },
  mounted() {
    function initHterm(that, hterm1, lib1) {
      hterm1.defaultStorage = new lib1.Storage.Local();
      lib1.init(function() {
        // opt_profileName is the name of the terminal profile to load, or "default" if
        // not specified.  If you're using one of the persistent storage
        // implementations then this will scope all preferences read/writes to this
        // name.
        const optProfileName = "default";
        const t = new hterm1.Terminal(optProfileName);
        t.prefs_.set("alt-sends-what", "8-bit");
        // to support non-ascii,  ex: Chinese
        t.prefs_.set("send-encoding", "raw");
        t.prefs_.set(
          "font-family",
          "Droid Sans Mono for Powerline, courier new, Helvetica, Arial, sans-serif"
        );
        t.prefs_.set("font-size", "12px");

        t.onTerminalReady = () => {
          // Create a new terminal IO object and give it the foreground.
          // (The default IO object just prints warning messages about unhandled
          // things to the the JS console.)
          const io = t.io.push();
          that.io = io;

          io.onVTKeystroke = str => {
            // Do something useful with str here.
            // For example, Secure Shell forwards the string onto the NaCl plugin.
            // io.print(str)
            that.sendMessage("data", str);
          };

          io.sendString = str => {
            // Just like a keystroke, except str was generated by the terminal itself.
            // For example, when the user pastes a string.
            // Most likely you'll do the same thing as onVTKeystroke.
            that.sendMessage("data", str);
          };

          io.onTerminalResize = (columns, rows) => {
            // React to size changes here.
            // Secure Shell pokes at NaCl, which eventually results in
            // some ioctls on the host.
            // console.log(`resize, ${columns}, ${rows}`)
            that.cols = columns;
            that.rows = rows;
            that.sendMessage("resize", { col: columns, row: rows });
          };

          // You can call io.push() to foreground a fresh io context, which can
          // be uses to give control of the terminal to something else.  When that
          // thing is complete, should call io.pop() to restore control to the
          // previous io object.
        };

        // console.log(that.$refs.termDiv)
        t.decorate(that.$refs.termDiv);
        t.setCursorPosition(0, 0);
        t.setCursorVisible(true);
        t.installKeyboard();
        that.terminal = t;
      }); // -- lib.init
    }

    initHterm(this, hterm, lib);

    // const that = this
    // import(/* webpackChunkName: "hterm" */ 'hterm-umdjs').then( module => {
    //  const hterm = module.hterm
    //  const lib = module.lib
    //  initHterm(that, hterm, lib)
    // })
  },

  data() {
    return {
      ws: null,
      wsConnected: false,
      io: null,
      connection: "",
      cols: 80,
      rows: 30,
      auth: GlobalStore.auth,
      terminal: null,
      options: {}
    };
  },

  methods: {
    logout() {
      this.auth.logout();
      ls("token", "");
      this.auth.clearToken();
    },

    sendMessage(op, data) {
      if (this.wsConnected) {
        this.ws.send(JSON.stringify({ op, data }));
      } else {
        console.warn("connection is not open.");
      }
    },

    reqSShConnect(options) {
      const { sshuser, sshhost, sshport } = options;
      let port = 22;
      if (sshport !== null) port = sshport;
      this.sendMessage("connect", {
        sshuser: sshuser,
        sshhost: sshhost,
        sshport: port,
        cols: this.cols,
        rows: this.rows,
        options
      });
    },

    socketOpen(options) {
      if (this.wsConnected) {
        this.ws.close();
      }
      this.options = options;
      this.connection = `${options.sshuser}@${options.sshhost}`;

      let { host, protocol } = window.location;
      let wsUrl = `${protocol}//${host}/ws`.replace("http", "ws");

      this.ws = new W3cwebsocket(wsUrl, this.auth.token);
      this.ws.onopen = () => {
        this.wsConnected = true;
        if (this.terminal) this.terminal.focus();
        this.reqSShConnect(options);
      };
      this.ws.onclose = () => {
        this.wsConnected = false;
        this.io.println("Remotion connection closed.");
      };
      this.ws.onerror = () => {
        this.ws.close();
      };

      this.ws.onmessage = msg => {
        this.io.print(msg.data);
      };
    },

    connectToggle() {
      if (this.wsConnected) this.ws.close();
      else this.socketOpen(this.options);
    }
  }
};
</script>
